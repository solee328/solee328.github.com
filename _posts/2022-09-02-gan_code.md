---
layout: post
title: GAN(2) - 논문 구현
# subtitle:
categories: gan
tags: [gan, 생성 모델, 논문 구현]
# sidebar: []
use_math: true
---


## 1. 데이터
MNIST 데이터셋을 사용했습니다. torchvision에서 코드를 통해 다운받고 쓸 수 있으니 따로 다운받으실 필요없이 편하게 사용할 수 있습니다.
다만 다운받았을 때 torchvision의 데이터는 `PIL.Image.Image`타입으로 들어오게 됩니다.
`Tensor`로 변경하기 위해 transform 부분 코드를 넣어 데이터 타입을 변경해주어야 합니다.
```python
dataloader = DataLoader(
    datasets.MNIST('/content/drive/MyDrive/Colab Notebooks/gan/data',
                   train=True,
                   download=True,
                   transform=transforms.Compose([transforms.ToTensor()])),
    batch_size=batch_size,
    shuffle=True,
    drop_last=True)
```

<br><br>
데이터 확인을 위해 plt로 출력해보겠습니다.
```python
images, labels = next(iter(dataloader))

fig = plt.figure(figsize=(8, 8))
for idx in range(4):
  image = images[idx]
  label = labels[idx]

  fig.add_subplot(1, 4, idx+1)
  plt.axis('off')
  plt.title(label)
  plt.imshow(image[0], cmap='gray')

fig.tight_layout()
plt.show()
```
라벨값과 함께 이미지를 확인할 수 있었습니다.


## 2. 모델


### 2.1. Generator

```python
class Generator(nn.Module):
  def __init__(self, z_dim=100, img_shape=(28,28)):
    super(Generator, self).__init__()

    self.z_dim = z_dim
    self.img_shape=img_shape

    self.model = nn.Sequential(
        nn.Linear(self.z_dim, 256),
        nn.ReLU(),
        nn.Linear(256, 512),
        nn.ReLU(),
        nn.Linear(512, 784),
        nn.Sigmoid()
    )

  def forward(self, z):
      img = self.model(z)
      img = img.view(img.size(0), *self.img_shape)
      return img
```

### 2.2. Discriminator

```python
class Maxout(nn.Module):
  def __init__(self, k=3):
    super(Maxout, self).__init__()

    self.k = k

    # random normal로 initialize
    self.weight = torch.randn(self.k).unsqueeze(1).cuda()
    self.bias = torch.randn(self.k).unsqueeze(0).cuda()

  def forward(self, input):
    x = input.flatten().unsqueeze(1)
    x = nn.functional.linear(x, self.weight, self.bias)
    x = nn.functional.max_pool1d(x, self.k)
    x = x.reshape(*input.shape)
    return x
```


```python
class Discriminator(nn.Module):
  def __init__(self, img_shape=28*28):
    super(Discriminator, self).__init__()

    self.model = nn.Sequential(
        nn.Linear(img_shape, 512),
        Maxout(),
        nn.Dropout(0.5),
        nn.Linear(512, 256),
        Maxout(),
        nn.Linear(256, 1),
        nn.Sigmoid()
    )

  def forward(self, img):
    output = self.model(img)
    return output
```


## 3. 결과

loss, optimizer, z
```python
loss = nn.BCELoss().cuda()

optimizer_G = torch.optim.SGD(generator.parameters(), lr=learning_rate)
optimizer_D = torch.optim.SGD(discriminator.parameters(), lr=learning_rate)

z = torch.zeros(batch_size, z_dim)
z += (0.1**0.5)*torch.randn(batch_size, z_dim)
z = z.cuda()
```

## 4. 최적화


### 4.1. lr, Adam


### 4.2. norm, label


## 5. 최종결과
